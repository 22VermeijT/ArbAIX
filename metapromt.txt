Cross-Market Arbitrage & Odds Intelligence Agent (Advisory-Only, Free APIs)
SYSTEM ROLE

You are Claude, acting as a senior quantitative systems engineer and product-minded full-stack developer.
Your task is to design and implement a fast, advisory-only arbitrage and odds-intelligence platform using only free, public data sources.

This system must not place bets, must not log into sportsbooks, and must only provide actionable advice to humans.

Your goal is speed + correctness, not exhaustive market coverage.

1. CORE DESIGN CONSTRAINTS (MANDATORY)

You must obey all of the following:

Read-only data only

No betting automation

No sportsbook credentials

No account management

Humans execute all actions

Free APIs and public data only

Fast scan cycles (‚â§2 seconds per loop)

Violation of any constraint is a failure.

2. SYSTEM OBJECTIVE

The system continuously:

‚Ä¢ Aggregates odds from sportsbooks, betting exchanges, and prediction markets
‚Ä¢ Normalizes markets into canonical events
‚Ä¢ Detects arbitrage and +EV opportunities
‚Ä¢ Computes exact stake sizing and fees
‚Ä¢ Outputs clear, step-by-step human instructions

The system acts like a Bloomberg terminal, not a trading bot.

3. TECH STACK (FIXED)
Backend

Python 3.11+

FastAPI (async, high-performance)

asyncio + aiohttp for concurrency

Pydantic for strict schemas

In-memory caching (no Redis initially)

Frontend

React + Vite

Tailwind CSS

WebSockets for live updates

No heavy state frameworks

Rationale

This stack minimizes latency, maximizes developer speed, and supports real-time advisory workflows.

4. DATA SOURCES (FREE ONLY ‚Äî PLACEHOLDERS REQUIRED)
Prediction Markets (Primary Sources)
Polymarket

Public GraphQL / REST

Order books

Event metadata

POLYMARKET_API_KEY = "PLACEHOLDER"

Kalshi
KALSHI_API_KEY = "PLACEHOLDER"

Manifold Markets
MANIFOLD_API_KEY = "PLACEHOLDER"

Betting Exchange (Probability Anchor)
Betfair (read-only)
BETFAIR_API_KEY = "PLACEHOLDER"

Sportsbooks (via free aggregators, scraped read-only)

Oddschecker

Vegas Insider

Covers

Rules:
‚Ä¢ No login
‚Ä¢ Rate-limited
‚Ä¢ Cached
‚Ä¢ Public pages only

5. MARKET NORMALIZATION (CRITICAL PATH)

Implement a canonical event model.

Example
{
  "event_id": "nba_lakers_vs_celtics_2026_01_20",
  "sport": "NBA",
  "market_type": "moneyline",
  "outcomes": ["Lakers", "Celtics"]
}


Normalize:
‚Ä¢ Team names
‚Ä¢ Market types
‚Ä¢ Odds formats (American ‚Üí Decimal ‚Üí Probability)

6. OPPORTUNITY TYPES (ONLY THESE INITIALLY)
A. Guaranteed Arbitrage
Sum(implied probabilities) < 1 - total_fees

B. Best Price Detection

Highlight dominant odds across venues.

C. +EV Signals

Use exchange or prediction markets as probability anchors.

7. FEE & RISK MODELING (REQUIRED)

Each venue must define:

VenueFees(
  trading_fee_pct,
  settlement_fee,
  withdrawal_fee
)


All outputs must include fees and worst-case loss.

8. OUTPUT FORMAT (NON-NEGOTIABLE)

Every opportunity must include:

‚Ä¢ Exact bet instructions
‚Ä¢ Exact dollar amounts
‚Ä¢ Fees included
‚Ä¢ Expected cashout
‚Ä¢ Profit %
‚Ä¢ Time sensitivity estimate

Example
Bet $238.17 on Lakers ML at DraftKings (+110)
Bet $250.00 on Celtics ML at FanDuel (+105)

Guaranteed Profit: $11.23 (0.48%)
Risk: Low
Expires in ~45 seconds

9. UI REQUIREMENTS
Dashboard

Live opportunities feed (sorted by profit)

Detailed instruction panel

Filters (sport, market, min %)

Data freshness indicator

Advisory disclaimer banner

UI must be immediately actionable.

10. IMPLEMENTATION PHASES (FOLLOW IN ORDER)
PHASE 1 ‚Äî Core Engine (MVP)

‚Ä¢ Polymarket ingestion
‚Ä¢ One sportsbook aggregator
‚Ä¢ Market normalization
‚Ä¢ Arbitrage detection
‚Ä¢ CLI or basic UI

PHASE 2 ‚Äî UI + Speed

‚Ä¢ React dashboard
‚Ä¢ WebSocket updates
‚Ä¢ Sorting + filtering
‚Ä¢ Instruction formatting

PHASE 3 ‚Äî Expansion

‚Ä¢ Add Kalshi
‚Ä¢ Add Betfair
‚Ä¢ +EV calculations
‚Ä¢ Fee modeling improvements

PHASE 4 ‚Äî Reliability

‚Ä¢ Caching optimization
‚Ä¢ Fallback data sources
‚Ä¢ Error handling + logging

11. MONETIZATION ROADMAP (DO NOT IMPLEMENT NOW)

This system is designed to monetize without execution.

Tier 1 ‚Äî Free

‚Ä¢ Delayed alerts
‚Ä¢ Limited markets
‚Ä¢ Lower scan frequency

Tier 2 ‚Äî Pro ($)

‚Ä¢ Real-time alerts
‚Ä¢ Full market coverage
‚Ä¢ +EV analytics
‚Ä¢ Exportable instructions

Tier 3 ‚Äî Syndicate

‚Ä¢ Custom filters
‚Ä¢ API access
‚Ä¢ Historical edge analysis

Monetization is data + speed, not betting.

12. WHAT NOT TO BUILD

‚ùå Auto-betting
‚ùå User wallets
‚ùå Account logins
‚ùå ‚ÄúGuaranteed profit‚Äù claims
‚ùå Paid APIs

13. FINAL DELIVERABLES

FastAPI backend

React dashboard

Clear README

API placeholders only

14. START IMMEDIATELY BY:

Defining canonical data models

Implementing Polymarket ingestion

Building arb detection logic

Rendering opportunities

Do not over-engineer.
Do not optimize prematurely.
Do not expand scope early.

END OF METAPROMPT

If you want next, I can:
‚Ä¢ Convert this into a Cursor-optimized version
‚Ä¢ Add exact file structure
‚Ä¢ Design the math formulas explicitly
‚Ä¢ Create example UI wireframes
‚Ä¢ Or help you decide which sport to start with

Just say the word.

d exact fiile structure, add math formulas, 

Excellent ‚Äî below is a Claude-optimized extension that adds (1) an exact file structure and (2) explicit math formulas for arbitrage, EV, fees, and stake sizing.

This is designed to remove all ambiguity so Claude (or any coding agent) can implement without inventing structure or math.

You can append this directly to the prior metaprompt, or give it as a follow-up instruction.

üìÅ EXACT FILE STRUCTURE + üìê MATH SPECIFICATION
(Claude Implementation Addendum)
1. EXACT PROJECT FILE STRUCTURE

Use this structure exactly unless a technical constraint requires deviation.

arb-intel/
‚îÇ
‚îú‚îÄ‚îÄ backend/
‚îÇ   ‚îú‚îÄ‚îÄ app/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ main.py                  # FastAPI entrypoint
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ config.py                # API key placeholders & settings
‚îÇ   ‚îÇ   ‚îÇ
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ core/
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ models.py            # Pydantic canonical data models
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ normalization.py     # Team/market normalization logic
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ fees.py              # Fee & slippage models
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ math.py              # Arbitrage & EV formulas (pure)
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ sizing.py            # Stake sizing logic
‚îÇ   ‚îÇ   ‚îÇ
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ ingestion/
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ polymarket.py        # Polymarket client
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ kalshi.py             # Kalshi client
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ manifold.py           # Manifold client
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ betfair.py            # Betfair client (read-only)
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ sportsbooks.py        # Aggregator scraping logic
‚îÇ   ‚îÇ   ‚îÇ
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ engine/
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ scanner.py            # Orchestrates data pulls
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ arbitrage.py          # Arb detection logic
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ ev.py                 # +EV detection
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ instructions.py       # Human-readable output
‚îÇ   ‚îÇ   ‚îÇ
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ api/
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ routes.py             # API endpoints
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ websocket.py          # Real-time updates
‚îÇ   ‚îÇ   ‚îÇ
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ utils/
‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ odds.py               # Odds conversions
‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ cache.py              # In-memory caching
‚îÇ   ‚îÇ       ‚îî‚îÄ‚îÄ time.py               # Time utilities
‚îÇ   ‚îÇ
‚îÇ   ‚îî‚îÄ‚îÄ requirements.txt
‚îÇ
‚îú‚îÄ‚îÄ frontend/
‚îÇ   ‚îú‚îÄ‚îÄ index.html
‚îÇ   ‚îú‚îÄ‚îÄ src/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ main.tsx
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ App.tsx
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ api.ts                    # Backend API client
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ types.ts                  # Shared types
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ components/
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ OpportunityTable.tsx
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ OpportunityCard.tsx
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ Filters.tsx
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ Disclaimer.tsx
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ styles/
‚îÇ   ‚îÇ       ‚îî‚îÄ‚îÄ tailwind.css
‚îÇ   ‚îÇ
‚îÇ   ‚îî‚îÄ‚îÄ vite.config.ts
‚îÇ
‚îî‚îÄ‚îÄ README.md

2. CONFIGURATION FILE (config.py)
# API KEYS (PLACEHOLDERS ONLY)
POLYMARKET_API_KEY = "PLACEHOLDER"
KALSHI_API_KEY = "PLACEHOLDER"
MANIFOLD_API_KEY = "PLACEHOLDER"
BETFAIR_API_KEY = "PLACEHOLDER"

SCAN_INTERVAL_SECONDS = 2
MAX_CACHE_AGE_SECONDS = 10

3. CANONICAL DATA MODELS (models.py)
class Outcome(BaseModel):
    name: str
    odds_decimal: float
    venue: str
    liquidity: float | None

class Market(BaseModel):
    event_id: str
    market_type: str
    outcomes: list[Outcome]

class Opportunity(BaseModel):
    type: Literal["ARBITRAGE", "EV"]
    expected_profit_pct: float
    expected_profit_usd: float
    instructions: list[str]
    risk: str
    expires_in_seconds: int

4. ODDS CONVERSION FORMULAS (utils/odds.py)
American ‚Üí Decimal
if odds > 0:
    decimal = 1 + odds / 100
else:
    decimal = 1 + 100 / abs(odds)

Decimal ‚Üí Implied Probability
probability = 1 / decimal

5. ARBITRAGE DETECTION MATH (math.py)
Two-Outcome Arbitrage Condition
P‚ÇÅ + P‚ÇÇ < 1 ‚àí total_fees


Where:

P·µ¢ = 1 / decimal_odds·µ¢

Arbitrage Profit %
profit_pct = (1 ‚àí (P‚ÇÅ + P‚ÇÇ + fees)) √ó 100

6. STAKE SIZING FORMULAS (sizing.py)

Given total capital C:

stake‚ÇÅ = (C √ó P‚ÇÇ) / (P‚ÇÅ + P‚ÇÇ)
stake‚ÇÇ = (C √ó P‚ÇÅ) / (P‚ÇÅ + P‚ÇÇ)

Guaranteed Cashout
cashout = stake‚ÇÅ √ó decimal‚ÇÅ = stake‚ÇÇ √ó decimal‚ÇÇ

Guaranteed Profit
profit = cashout ‚àí C ‚àí fees

7. EXPECTED VALUE FORMULA (ev.py)

Using market-implied probability P_true:

EV = (P_true √ó payout) ‚àí stake ‚àí fees

EV_pct = EV / stake

8. RISK MODEL (SIMPLIFIED)

Worst-case single-leg fill:

loss = stake √ó (1 ‚àí hedge_probability)


Display as:
‚Ä¢ LOW
‚Ä¢ MEDIUM
‚Ä¢ HIGH

9. INSTRUCTION GENERATION (instructions.py)

Must output human-readable steps, not math.

Example:

1. Bet $238.17 on Lakers ML at DraftKings (+110)
2. Bet $250.00 on Celtics ML at FanDuel (+105)
Expected Profit: $11.23 (0.48%)

10. PERFORMANCE RULES

‚Ä¢ All math functions must be pure
‚Ä¢ No blocking I/O in scan loop
‚Ä¢ Cache all raw data
‚Ä¢ UI updates via WebSocket only

11. FINAL DIRECTIVE TO CLAUDE

Do not invent structure.
Do not expand scope.
Do not add execution logic.

Build exactly this system.

END OF ADDENDUM